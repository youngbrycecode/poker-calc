#include "Poker.h"
#include <string.h>
#include <algorithm>

#include "LookupTables.h"

namespace sim
{
   namespace
   {
      constexpr uint32_t Max32BitInt = std::numeric_limits<uint32_t>::max();
      constexpr uint32_t StraightFlushBitMask = 0xFFFFF;
      constexpr uint32_t FlushBitMask = 0b1111111111111;

      void SetBitFieldsAndAddCard(card_t card, tClassificationData& data)
      {
         if (card == NotACard) return;

         const int rank = static_cast<int>(Card::GetRank(card));
         const int suit = static_cast<int>(Card::GetSuit(card));

         data.CardsBitField |= (1ull << suit) << (rank << 2);

         data.RankBitFields[rank] |= 1 << suit;
         data.SuitBitFields[suit] |= 1 << rank;

         data.RankBitField |= 1 << rank;

         data.RankCardCount[rank]++;
         data.SuitCardCount[suit]++;

         if (card > data.HighestCard)
         {
            data.HighestCard = card;
         }

         if (card < data.LowestCard)
         {
            data.LowestCard = card;
         }
      }

      void SetBitFieldsAndAddCardFast(card_t card, tClassificationData& data)
      {
         if (card == NotACard) return;

         const int rank = static_cast<int>(Card::GetRank(card));
         const int suit = static_cast<int>(Card::GetSuit(card));

         data.CardsBitField |= (1ULL << suit) << (rank << 2);
         data.SuitCardCount[suit]++;

         if (card > data.HighestCard)
         {
            data.HighestCard = card;
         }

         if (card < data.LowestCard)
         {
            data.LowestCard = card;
         }
      }

      void ProcessHand(tClassificationData& data);

      // Accelerates the time of classifying hands using lookup tables. These lookup tables are generated by the
      // Slower, more brute for ProcessHand method.
      void ProcessHandFast(tClassificationData& data);
   }

   void HandClassification::ClassifyArbitraryNumCards(card_t* cards, int numCards)
   {
      if (numCards < 1) return;

      // Clear the bit fields.
      mAllCardsClassData.RankBitField = 0;
      mAllCardsClassData.CardsBitField = 0;
      mAllCardsClassData.HighestCard = cards[0];
      mAllCardsClassData.LowestCard = cards[0];

      memset(mAllCardsClassData.RankBitFields, 0, sizeof(mAllCardsClassData.RankBitFields));
      memset(mAllCardsClassData.SuitBitFields, 0, sizeof(mAllCardsClassData.SuitBitFields));

      // Clear the card data.
      memset(mAllCardsClassData.RankCardCount, 0, sizeof(mAllCardsClassData.RankCardCount));
      memset(mAllCardsClassData.SuitCardCount, 0, sizeof(mAllCardsClassData.SuitCardCount));
      memset(mAllCardsClassData.ClassesTested, tClassificationData::Fail, sizeof(mAllCardsClassData.ClassesTested));

      for (int i = 0; i < numCards; i++)
      {
         SetBitFieldsAndAddCard(cards[i], mAllCardsClassData);
      }

      // Set the high card.
      mAllCardsClassData.ClassesTested[static_cast<int>(HandClass::HighCard)] = tClassificationData::Pass;
      mAllCardsClassData.HighCard.HighRank = Card::GetRank(mAllCardsClassData.HighestCard);

      ProcessHand(mAllCardsClassData);

      int classificationIndex = static_cast<int>(HandClass::MaxClassification) - 1;
      while (mAllCardsClassData.ClassesTested[classificationIndex] == tClassificationData::Fail)
      {
         classificationIndex--;
      }

      mAllCardsClassData.HandClassification = static_cast<HandClass>(classificationIndex);
   }

   void HandClassification::ClassifyAllCardsFast(card_t hand1, card_t hand2,
      card_t flop1, card_t flop2, card_t flop3,
      card_t turn, card_t river)
   {
      // Clear the bit fields.
      // Note, we don't actually have to clear all fields since the classify 
      // fast algorithm doesn't use all of it. Just clear what we need to!
      mAllCardsClassData.HighestCard = hand1;
      mAllCardsClassData.LowestCard = hand1;
      mAllCardsClassData.CardsBitField = 0;

      static_assert(sizeof(mAllCardsClassData.SuitCardCount) == sizeof(uint32_t));
      *(reinterpret_cast<uint32_t*>(mAllCardsClassData.SuitCardCount)) = 0;
      memset(mAllCardsClassData.ClassesTested, tClassificationData::Fail, sizeof(mAllCardsClassData.ClassesTested));

      SetBitFieldsAndAddCardFast(hand1, mAllCardsClassData);
      SetBitFieldsAndAddCardFast(hand2, mAllCardsClassData);
      SetBitFieldsAndAddCardFast(flop1, mAllCardsClassData);
      SetBitFieldsAndAddCardFast(flop2, mAllCardsClassData);
      SetBitFieldsAndAddCardFast(flop3, mAllCardsClassData);
      SetBitFieldsAndAddCardFast(turn, mAllCardsClassData);
      SetBitFieldsAndAddCardFast(river, mAllCardsClassData);

      // Set the high card.
      mAllCardsClassData.ClassesTested[static_cast<int>(HandClass::HighCard)] = tClassificationData::Pass;
      mAllCardsClassData.HighCard.HighRank = Card::GetRank(mAllCardsClassData.HighestCard);

      ProcessHandFast(mAllCardsClassData);

      int classificationIndex = static_cast<int>(HandClass::MaxClassification) - 1;
      while (mAllCardsClassData.ClassesTested[classificationIndex] == tClassificationData::Fail)
      {
         classificationIndex--;
      }

      mAllCardsClassData.HandClassification = static_cast<HandClass>(classificationIndex);
   }

   namespace
   {
      void ProcessHand(tClassificationData& data)
      {         
         // Keep a running total of the number of pairs and n of a kinds we find in the hand.
         int pairCount = 0;
         int nOfAKindCount = 0;

         for (int cardRank = static_cast<int>(Rank::Ace);
            cardRank >= static_cast<int>(Rank::Two); cardRank--)
         {
            // Create straight bit field (to be used later).
            // Init to max value to ensure remove the need for another boolean checking if we have
            // the possibility for a straight.
            uint32_t straightBitField = Max32BitInt;

            if (cardRank >= 3)
            {
               if (cardRank >= 4)
               {
                  straightBitField = 0b11111 << (cardRank - 4);
               }
               else
               {
                  // Include the ace bit since it can also count as zero.
                  straightBitField = 0b1000000001111;
               }
            }

            // Check for a standard straight at this rank.
            if ((data.RankBitField & straightBitField) == straightBitField &&
               data.ClassesTested[static_cast<int>(HandClass::Straight)] == tClassificationData::Fail)
            {
               data.Straight.HighRank = static_cast<Rank>(cardRank);
               data.ClassesTested[static_cast<int>(HandClass::Straight)] = tClassificationData::Pass;
            }

            // Check for straight flush and royal flush.
            for (int j = 0; j < static_cast<int>(Suit::MaxSuit); j++)
            {
               const bool passedBitFieldTest = (data.SuitBitFields[j] & straightBitField) == straightBitField;

               if (passedBitFieldTest && cardRank == static_cast<int>(Rank::Ace))
               {
                  data.ClassesTested[static_cast<int>(HandClass::RoyalFlush)] = tClassificationData::Pass;
               }

               if (passedBitFieldTest && data.ClassesTested[static_cast<int>(HandClass::StraightFlush)] == tClassificationData::Fail)
               {
                  data.ClassesTested[static_cast<int>(HandClass::StraightFlush)] = tClassificationData::Pass;
                  data.StraightFlush.HighRank = static_cast<Rank>(cardRank);
               }
            }

            const uint32_t numCardsWithRank = data.RankCardCount[cardRank];

            // If we got counts higher than 1, record here.
            if (numCardsWithRank == 2)
            {
               if (numCardsWithRank == 2 && data.ClassesTested[static_cast<int>(HandClass::OnePair)] == tClassificationData::Fail)
               {
                  data.OnePair.HighRank = static_cast<Rank>(cardRank);
                  data.ClassesTested[static_cast<int>(HandClass::OnePair)] = tClassificationData::Pass;
               }
               else if (numCardsWithRank == 2 && data.ClassesTested[static_cast<int>(HandClass::TwoPair)] == tClassificationData::Fail)
               {
                  data.TwoPair.SecondPairRank = static_cast<Rank>(cardRank);
                  data.ClassesTested[static_cast<int>(HandClass::TwoPair)] = tClassificationData::Pass;
               }

               pairCount++;
            }
            else if (numCardsWithRank > 2)
            {
               if (numCardsWithRank == 3 && data.ClassesTested[static_cast<int>(HandClass::ThreeOfAKind)] == tClassificationData::Fail)
               {
                  data.ThreeOfAKind.HighRank = static_cast<Rank>(cardRank);
                  data.ClassesTested[static_cast<int>(HandClass::ThreeOfAKind)] = tClassificationData::Pass;
               }
               else if (numCardsWithRank == 4 && data.ClassesTested[static_cast<int>(HandClass::FourOfAKind)] == tClassificationData::Fail)
               {
                  data.FourOfAKind.HighRank = static_cast<Rank>(cardRank);
                  data.ClassesTested[static_cast<int>(HandClass::FourOfAKind)] = tClassificationData::Pass;
               }

               nOfAKindCount++;
            }
         }

         // Set flush data.
         for (int i = 0; i < static_cast<int>(Suit::MaxSuit); i++)
         {
            if (data.SuitCardCount[i] >= 5)
            {
               data.ClassesTested[static_cast<int>(HandClass::Flush)] = tClassificationData::Pass;
               data.Flush.FlushSuit = static_cast<Suit>(i);
            }
         }

         // A full house can be made with the following:
         // 1. A pair and any number of n of a kinds.
         // 2. More than two n of a kinds.
         if ((pairCount >= 1 && nOfAKindCount >= 1) ||
             (nOfAKindCount >= 2))
         {
            data.ClassesTested[static_cast<int>(HandClass::FullHouse)] = tClassificationData::Pass;
         }
      }

      void ProcessHandFast(tClassificationData& data)
      {
         // Keep a running total of the number of pairs and n of a kinds we find in the hand.
         int pairCount = 0;
         int nOfAKindCount = 0;
         
         for (int cardRank = static_cast<int>(Rank::Ace);
            cardRank >= static_cast<int>(Rank::Two); cardRank--)
         {
            HandClass foundHandClass = HandClass::HighCard;

            if (cardRank >= 4)
            {
               const uint32_t bitShift = (cardRank - 4) << 2;
               const uint64_t straightBits = (data.CardsBitField >> bitShift) & StraightFlushBitMask;
               foundHandClass = static_cast<HandClass>(StraightFlushLookupTable[straightBits]);
            }
            else if (cardRank >= 3)
            {
               // OLD COMMENT, just because it made me laugh to re-read months later.
               // A straight cannot be made the normal way, but it can be made with an ace as the low card.
               // Standard low straight is 2, 3, 4, 5, 6. This would be ACE, 2, 3, 4, 5
               // (2-5) is stored in the upper 16 bits of the flush bit field, then the 4 bits describing aces in the hand are ORd
               // to the front to take the "TWO" position.
               // Shift the hand data to the right by 4 bits, OR in the ACE data, and mask with the straight flush bits then perform the same
               // tests.

               // NEW COMMENT:
               // In poker, a straight can include an Ace as the low card, making the sequence Ace, 2, 3, 4, 5.
               // To check for this special straight, we shift the hand data to the left by 4 bits,
               // effectively moving the Ace data to the "TWO" position.
               // We then extract the Ace data (if present) using a mask and shift it back to its original position.
               // Finally, we combine this with the rest of the hand data and check for a straight flush.

               // Shift the hand data to the left by 4 bits to prepare for the special straight with an Ace.
               uint64_t straightBits = data.CardsBitField << 4;

               // Define a bit shift for the Ace rank to align it with the "TWO" position.
               constexpr uint32_t bitShift = static_cast<int>(Rank::Ace) << 2;

               // Create a mask to extract the Ace bits from the hand data.
               constexpr uint64_t aceMask = 0xFULL << bitShift;

               // Extract the Ace bits and shift them back to "TWO" position.
               const uint64_t aceBits = (data.CardsBitField & aceMask) >> bitShift;

               // Combine the Ace bits with the rest of the hand data.
               straightBits |= aceBits;

               // Ensure only the relevant bits for a straight flush are considered.
               straightBits &= StraightFlushBitMask;

               // Use a lookup table to determine the hand class based on the bits representing the straight.
               foundHandClass = static_cast<HandClass>(StraightFlushLookupTable[straightBits]);
            }

            if (foundHandClass == HandClass::Straight &&
               data.ClassesTested[static_cast<int>(HandClass::Straight) == tClassificationData::Fail])
            {
               data.Straight.HighRank = static_cast<Rank>(cardRank);
               data.ClassesTested[static_cast<int>(HandClass::Straight)] = tClassificationData::Pass;
            }
            else if (foundHandClass == HandClass::StraightFlush &&
               data.ClassesTested[static_cast<int>(HandClass::StraightFlush)] == tClassificationData::Fail)
            {
               if (cardRank == static_cast<int>(Rank::Ace))
               {
                  data.ClassesTested[static_cast<int>(HandClass::RoyalFlush)] = tClassificationData::Pass;
               }

               data.ClassesTested[static_cast<int>(HandClass::StraightFlush)] = tClassificationData::Pass;
               data.StraightFlush.HighRank = static_cast<Rank>(cardRank);
            }

            const uint32_t bitShift = cardRank << 2;
            const uint64_t mask = 0xFULL << bitShift;
            const uint64_t numCardsWithRankBits = ((data.CardsBitField & mask) >> bitShift) & 0xF;
            const uint8_t numCardsWithRank = RankCardCountLookupTable[numCardsWithRankBits];

            // If we got counts higher than 1, record here.
            if (numCardsWithRank == 2) 
            {
               if (numCardsWithRank == 2 && data.ClassesTested[static_cast<int>(HandClass::OnePair)] == tClassificationData::Fail)
               {
                  data.OnePair.HighRank = static_cast<Rank>(cardRank);
                  data.ClassesTested[static_cast<int>(HandClass::OnePair)] = tClassificationData::Pass;
               }
               else if (numCardsWithRank == 2 && data.ClassesTested[static_cast<int>(HandClass::TwoPair)] == tClassificationData::Fail)
               {
                  data.TwoPair.SecondPairRank = static_cast<Rank>(cardRank);
                  data.ClassesTested[static_cast<int>(HandClass::TwoPair)] = tClassificationData::Pass;
               }

               pairCount++;
            }
            else if (numCardsWithRank > 2)
            {
               if (numCardsWithRank == 3 && data.ClassesTested[static_cast<int>(HandClass::ThreeOfAKind)] == tClassificationData::Fail)
               {
                  data.ThreeOfAKind.HighRank = static_cast<Rank>(cardRank);
                  data.ClassesTested[static_cast<int>(HandClass::ThreeOfAKind)] = tClassificationData::Pass;
               }
               else if (numCardsWithRank == 4 && data.ClassesTested[static_cast<int>(HandClass::FourOfAKind)] == tClassificationData::Fail)
               {
                  data.FourOfAKind.HighRank = static_cast<Rank>(cardRank);
                  data.ClassesTested[static_cast<int>(HandClass::FourOfAKind)] = tClassificationData::Pass;
               }

               nOfAKindCount++;
            }
         }

         // Classify the flush
         if (data.SuitCardCount[static_cast<int>(Suit::Clubs)] >= 5) 
         {
            data.ClassesTested[static_cast<int>(HandClass::Flush)] = tClassificationData::Pass;
            data.Flush.FlushSuit = static_cast<Suit>(static_cast<int>(Suit::Clubs));
         }
         else if (data.SuitCardCount[static_cast<int>(Suit::Hearts)] >= 5) 
         {
            data.ClassesTested[static_cast<int>(HandClass::Flush)] = tClassificationData::Pass;
            data.Flush.FlushSuit = static_cast<Suit>(static_cast<int>(Suit::Hearts));
         }
         else if (data.SuitCardCount[static_cast<int>(Suit::Spades)] >= 5) 
         {
            data.ClassesTested[static_cast<int>(HandClass::Flush)] = tClassificationData::Pass;
            data.Flush.FlushSuit = static_cast<Suit>(static_cast<int>(Suit::Spades));
         }
         else if (data.SuitCardCount[static_cast<int>(Suit::Diamonds)] >= 5) 
         {
            data.ClassesTested[static_cast<int>(HandClass::Flush)] = tClassificationData::Pass;
            data.Flush.FlushSuit = static_cast<Suit>(static_cast<int>(Suit::Diamonds));
         }

         // A full house can be made with the following:
         // 1. A pair and any number of n of a kinds.
         // 2. More than two n of a kinds.
         if ((pairCount >= 1 && nOfAKindCount >= 1) || 
             (nOfAKindCount >= 2))
         {
            data.ClassesTested[static_cast<int>(HandClass::FullHouse)] = tClassificationData::Pass;
         }
      }
   }

   void HandClassification::PrintAllCardsClassification(std::ostream& outputStream)
   {
      switch (mAllCardsClassData.HandClassification)
      {
      case HandClass::HighCard:
      {
         card_t randomCardWithRank = Card::CreateCard((Rank)mAllCardsClassData.HighCard.HighRank, Suit::Clubs);
         outputStream << "High Card: ";
         Card::PrintRank(randomCardWithRank, outputStream);
      }
      break;
      case HandClass::OnePair:
      {
         card_t randomCardWithRank = Card::CreateCard((Rank)mAllCardsClassData.OnePair.HighRank, Suit::Clubs);
         outputStream << "One Pair:";
         Card::PrintRank(randomCardWithRank, outputStream);
      }
      break;
      case HandClass::TwoPair:
      {
         card_t randomCardWithRank = Card::CreateCard((Rank)mAllCardsClassData.OnePair.HighRank, Suit::Clubs);
         card_t randomCardWithRank2 = Card::CreateCard((Rank)mAllCardsClassData.TwoPair.SecondPairRank, Suit::Clubs);

         outputStream << "Two Pair: ";
         Card::PrintRank(randomCardWithRank, outputStream);
         Card::PrintRank(randomCardWithRank2, outputStream);
      }
      break;
      case HandClass::ThreeOfAKind:
      {
         card_t randomCardWithRank = Card::CreateCard((Rank)mAllCardsClassData.ThreeOfAKind.HighRank, Suit::Clubs);
         outputStream << "Three Of A Kind: ";
         Card::PrintRank(randomCardWithRank, outputStream);
      }
      break;
      case HandClass::Straight:
      {
         card_t randomCardWithRank = Card::CreateCard((Rank)mAllCardsClassData.Straight.HighRank, Suit::Clubs);
         outputStream << "Straight: ";
         Card::PrintRank(randomCardWithRank, outputStream);
      }
      break;
      case HandClass::Flush:
      {
         card_t randomCardWithSuit = Card::CreateCard(Rank::Two, mAllCardsClassData.Flush.FlushSuit);
         outputStream << "Flush: ";
         Card::PrintSuit(randomCardWithSuit, outputStream);
      }
      break;
      case HandClass::FullHouse:
      {
         card_t randomCardWithRank = Card::CreateCard((Rank)mAllCardsClassData.ThreeOfAKind.HighRank, Suit::Clubs);
         card_t randomCardWithRank2 = Card::CreateCard((Rank)mAllCardsClassData.OnePair.HighRank, Suit::Clubs);

         outputStream << "Full House: 3-";
         Card::PrintRank(randomCardWithRank, outputStream);
         outputStream << "2- ";
         Card::PrintRank(randomCardWithRank2, outputStream);
      }
      break;
      case HandClass::FourOfAKind:
      {
         card_t randomCardWithRank = Card::CreateCard((Rank)mAllCardsClassData.FourOfAKind.HighRank, Suit::Clubs);
         outputStream << "Four Of A Kind: ";
         Card::PrintRank(randomCardWithRank, outputStream);
      }
      break;
      case HandClass::StraightFlush:
      {
         card_t randomCardWithRank = Card::CreateCard((Rank)mAllCardsClassData.StraightFlush.HighRank, Suit::Clubs);
         outputStream << "Straight Flush: S-";
         Card::PrintRank(randomCardWithRank, outputStream);
      }

      break;
      case HandClass::RoyalFlush:
         outputStream << "Royal Flush!\n";
         break;
      default:
         break;
      }
   }
}